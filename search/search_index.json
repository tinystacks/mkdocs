{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the TinyStacks documentation. Let's get started in making your own Ops Console.</p> <p>OpsConsole is an open-source console for cloud operations that delivers a dashboard and workflow engine so developers can organize resources in sensible ways, view key service metadata in one place and automate cloud workflows. With a low-code, widget-based approach, developers can design custom dashboards and workflows and even build their own custom widgets.</p> <p>With the Ops Console, engineering and DevOps teams can: </p> <p>\u2705 Organize cloud resources with a single pane of glass \u2705 Build deep operational health dashboards \u2705 Share and run operational scripts via the CLI plugin \u2705 Manage cloud sprawl and automate resolution for underutilized resources</p> <p>The platform comes with default plugins that offer a variety of features such as widgets for AWS ECS services and deployments, IAM JSON Policy viewers, and an AWS CLI, among others. The widgets are interactive and can exchange information, which enables the creation of dynamic and robust dashboards. With a provider and plugin model, developers can customize and extend the Ops Console as much as they wish. The samples/ folder includes several samples of dashboards that can be configured via YAML.</p>"},{"location":"#what-problems-is-the-ops-console-intended-to-serve","title":"What problems is the Ops Console intended to serve?","text":"<ol> <li>Cloud sprawl is real - modern cloud applications are built with hundreds of cloud services and resources and difficult to manage. </li> <li>Viewing and organizing cloud resources (to your choice) is difficult especially when debugging or monitoring deployments. </li> <li>The daily workflows of engineers involve guessing through tens of screens and clicks to find information with no ability to save or build repeatable workflows. </li> <li>Inability for developers to centralize and evaluate cloud configurations alongside observability tools.</li> </ol>"},{"location":"#why-does-cloud-sprawl-matter","title":"Why does cloud sprawl matter?","text":"<p>Our founders spent six years at AWS and witnessed thousands of customer issued, that frankly shouldn't exist. </p> <ol> <li>Unable to find a resource because they were looking at the wrong region. </li> <li>Debugging a critical issue and facing difficulty reconciling info across observability tools and tens of service consoles. </li> <li>Navigating through endless screens and clicks just to find out which version of the container image is currently deployed. </li> <li>Broken glass syndrome of cleaning up resources and driving down costs. </li> </ol>"},{"location":"#what-can-customers-do-with-the-ops-console","title":"What can customers do with the Ops Console?","text":"<p>Developers can connect their cloud accounts and organize resources in sensible ways providing immediate cloud comprehensibility. Developers can then build dashboards with common widgets for deployments, environment variables, logs, alarms and even write their own. Teams can share and run operational scripts via the CLI widget embedded directly in the relavent dashboards. </p>"},{"location":"api/","title":"API Reference","text":""},{"location":"concepts/","title":"Concepts","text":"Name Description Console A console is a top level construct. It includes a name to identify itself, as well as dashboards, widgets, providers and dependencies. Dashboard A dashboard is a page that consists of an id, a route and list of widget references. Widget Widgets are components that have two functions: render and getData. getData is called in the API\u2019s server and is used to make external requests, do computations, etc. Once it is called, it sets some data on the widget itself that\u2019s passed back to the frontend, where render is called to display the widget. Providers Providers are the beating hearts of the Console. They can be long running and run in the background. They may be passed to widgets to provide sensitive information or long-lived information, whereas widgets are better written as quick request/response styled objects."},{"location":"concepts/#providers","title":"Providers","text":"<p>Currently supports AWS with plans to add others! AWS provider can be configured with local profiles or Access/Secret keys.  </p>"},{"location":"concepts/#aws","title":"AWS","text":"<pre><code>providers:\n  AwsLocalProvider:\n    id: AwsLocalProvider\n    type: AwsCredentialsProvider\n    credentials:\n      # Option A: local credentials\n      profileName: default \n      # Option B: Access/Secret keys (required when deploying with opsconsole deploy)\n      # AwsAccessKeyId:\n      # AwsSecretAccessKey: \n</code></pre>"},{"location":"concepts/#core-widgets","title":"Core widgets","text":"Name Description Panel This widget renders multiple internal widgets in a single direction, either vertical or horizontal. Tabs This widget renders multiple internal widgets in a tab view. Combine with panel or grid to make robust views. Grid This widget renders multiple internal widgets in a grid. Markdown This widget renders markdown. CLI This widget runs a bash command. The command may be multiple commands separated by ';'. You can also reference scripts that exist in the same directory as your config."},{"location":"concepts/#aws-widgets","title":"AWS widgets","text":"Name Description CloudWatch Logs Renders a widget containing logs from a CloudWatchLogs log group or log stream. CloudWatch Graph Renders a widget containing graphs populated by one or many CloudWatch metrics. ECS Info Renders a widget containing information about an ECS Service. ECS Deployments Renders a widget containing information about an ECS Service's current deployments."},{"location":"deployment/","title":"Deployment","text":""},{"location":"deployment/#local-deployment","title":"Local Deployment","text":"<p>To run the Ops Console locally, just use the <code>opsconsole up</code> command. Its that simple!</p> <pre><code>opsconsole up -c DASHBOARD_NAME.yaml\n</code></pre>"},{"location":"deployment/#hosted-deployment","title":"Hosted Deployment","text":"<p>Deploy a hosted version of the TinyStacks Ops Console in minutes. </p> <pre><code># Routes to signup UI to obtain an auth token\nopsconsole signup; \n\nopsconsole configure\n# paste your token here\n\n# deploy your Ops Console to the TinyStacks cloud!\nopsconsole deploy -c DASHBOARD-NAME.yaml\n</code></pre> <p>That's it! Deployments take a few minutes. </p> <ul> <li>Please note that when deploying a hosted version of the Ops Console, local AWS profiles in the AWS provider will not work. Instead, an access/secret key pair needs to be used.</li> </ul>"},{"location":"get-started/","title":"Getting started","text":"<p>Follow installation instructions below to get the CLI installed. For a very basic dashboard that contains all the default layout elements, simply run</p>"},{"location":"get-started/#installation","title":"Installation","text":"<pre><code># Install CLI\nnpm i -g @tinystacks/opsconsole;\n\n# Make sure you have Docker installed and ports 3000 and 8000 open.\n</code></pre>"},{"location":"get-started/#run-sample-dashboard","title":"Run sample dashboard","text":""},{"location":"get-started/#aws","title":"AWS","text":"<p>This package includes other sample dashboard as well. As an example, it includes a sample dashboard that has ECS and AWS account info. To use that, follow these steps:</p> <pre><code>curl https://raw.githubusercontent.com/tinystacks/opsconsole/main/samples/ecs-dashboard-sample.yml -o ecs-dashboard-sample.yml\n\n# Modify line 6 by changing [your AWS profile] to your local AWS profile name\n# Modify lines [22-24] by changing the region, ecs clustername, and ecs service names to match resources in your account\n\nopsconsole up -c ecs-dashboard-sample.yml\n</code></pre>"},{"location":"get-started/#basic","title":"Basic","text":"<pre><code>opsconsole init;\nopsconsole up;\n</code></pre>"},{"location":"installation/","title":"Installation and Deploying","text":""},{"location":"installation/#pre-requisites","title":"Pre-requisites","text":"<p>To use the default installation, you need to have docker installed.</p> <p>Windows users must have Docker Desktop running.</p> <p>Also please make sure that ports 8000 and 3000 are open, as those ports are used by the API and frontend. If these ports are reserved, you can pull down the docker images for each of these packages and change the docker run to map ports separately.</p>"},{"location":"installation/#install-from-the-global-npm-registry","title":"Install from the Global NPM registry","text":"<pre><code># Install from the public npm registry\nnpm i -g @tinystacks/opsconsole;\n\n# Use the CLI, refer to the usage guide below\nopsconsole -v;\n\n</code></pre>"},{"location":"installation/#local-installation","title":"Local Installation","text":"<pre><code># Clone this package\ngit clone https://github.com/tinystacks/opsconsole.git;\n\n# Install dependencies and build\nnpm i; npm run build;\n\n# Install the CLI globally\n# Using the -g option installs the ops cli to your shell scope instead of the package scope. \n#  It adds the CLI command to bin, allowing you to call opsconsole from anywhere\nnpm i -g;\n\n# Use the CLI, refer to the usage guide below\nopsconsole -v;\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#cli-commands","title":"CLI Commands","text":""},{"location":"usage/#opsconsole","title":"opsconsole","text":"<p>Shows usage and help information</p>"},{"location":"usage/#opsconsole-init","title":"opsconsole init","text":"<p>Creates a sample config file that includes a basic template. If you don't </p>"},{"location":"usage/#opsconsole-up","title":"opsconsole up","text":"<p>Starts the ops console by pulling down the docker images for the ops api (public.ecr.aws/tinystacks/ops-api) and frontend (public.ecr.aws/tinystacks/ops-frontend) and rebuilding them using dependencies included in your yaml file. This may take several minutes depending on your system's available resources. It creates a docker networking bridge called ops-console through which the containers communicate with each other.</p>"},{"location":"usage/#opsconsole-update","title":"opsconsole update","text":"<p>Updates the Ops Console CLI to the latest version</p>"},{"location":"usage/#additional-options","title":"Additional Options","text":"Flag Arguments Description -a, --arch \\&lt;arch&gt; Specifies the architecture. Defaults to 'x86'. Options: 'x86', 'arm' -c, --config-file \\&lt;config-file&gt; Specifies a config file. See the <code>samples</code> folder in this repo for sample config files. Looks for config.yml in the current working directory by default. -V, --verbose Displays additional logs. -b, --backend-port \\&lt;backend-port&gt; Specifies the port to be exposed by the backend service. Defaults to port 8000. -f, --frontend-port \\&lt;frontend-port&gt; Specifies the port to be exposed by the frontend service. Defaults to port 3000. -h, --help display help for this command"},{"location":"usage/#customizing-dashboards","title":"Customizing Dashboards","text":""},{"location":"usage/#using-widgets","title":"Using widgets","text":"<ol> <li>Define the widget in the <code>widgets</code> section of YAML</li> <li>Reference the widget in a dashboard</li> <li>Add the widget's source to the <code>dependencies</code> section of the YAML in the format <code>widget name: 'dependency package'</code></li> </ol>"},{"location":"usage/#using-providers","title":"Using providers","text":"<p>Providers provide data to widgets from an external provider. 1. Define the provider in the <code>providers</code> section 2. Reference the provider as a list item in widget.</p>"},{"location":"usage/#sharing-data-between-widgets","title":"Sharing data between widgets","text":"<p>Any property in a widget\u2019s YAML can be substituted for either the props or data of another widget. </p> Parameter Required Syntax Example Reference Yes $ref: [widget path] $ref: '#/Console/widgets/EcsInfo' Path No path: [path of data or props of the widget] path: region"}]}