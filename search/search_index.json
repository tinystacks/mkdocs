{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Welcome to the TinyStacks documentation. Let's get started in making your own Ops Console.</p> <p>OpsConsole is an open-source console for cloud operations that delivers a dashboard and workflow engine so developers can organize resources in sensible ways, view key service metadata in one place and automate cloud workflows. With a low-code, widget-based approach, developers can design custom dashboards and workflows and even build their own custom widgets.</p> <p>With the Ops Console, engineering and DevOps teams can: </p> <p>\u2705 Organize cloud resources with a single pane of glass \u2705 Build deep operational health dashboards \u2705 Share and run operational scripts via the CLI plugin \u2705 Manage cloud sprawl and automate resolution for underutilized resources</p> <p>The platform comes with default plugins that offer a variety of features such as widgets for AWS ECS services and deployments, IAM JSON Policy viewers, and an AWS CLI, among others. The widgets are interactive and can exchange information, which enables the creation of dynamic and robust dashboards. With a provider and plugin model, developers can customize and extend the Ops Console as much as they wish. The samples/ folder includes several samples of dashboards that can be configured via YAML.</p>"},{"location":"#what-problems-is-the-ops-console-intended-to-serve","title":"What problems is the Ops Console intended to serve?","text":"<ol> <li>Cloud sprawl is real - modern cloud applications are built with hundreds of cloud services and resources. It's tough to manage the sprawl. </li> <li>Viewing and organizing cloud resources (to your preference) is difficult especially when debugging or monitoring deployments.</li> <li>The daily workflows of engineers involve guessing through tens of screens and clicks to find information. There's no way to save these steps or build repeatable workflows.</li> <li>Inability for developers to centralize and evaluate cloud configurations alongside observability tools.</li> </ol>"},{"location":"#why-does-cloud-sprawl-matter","title":"Why does cloud sprawl matter?","text":"<p>Our founders spent six years at AWS and witnessed thousands of customer issues that frankly shouldn't exist. </p> <ol> <li>Unable to find a resource because they were looking at the wrong region. </li> <li>Debugging a critical issue and facing difficulty reconciling info across observability tools and tens of service consoles. </li> <li>Navigating through endless screens and clicks just to find out which version of the container image is currently deployed. </li> <li>Inability to clean up resources or drive down costs for fear of impacting production services or developer workflow.</li> </ol>"},{"location":"#what-can-customers-do-with-the-ops-console","title":"What can customers do with the Ops Console?","text":"<p>Developers can connect their cloud accounts and organize resources in sensible ways providing immediate cloud comprehensibility. Developers can then build dashboards with common widgets for deployments, environment variables, logs, alarms and even write their own. Teams can share and run operational scripts via the CLI widget embedded directly in the relavent dashboards. </p>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> CLI widget to save and run scripts</li> <li> Executable actions within widgets (ex. kill task for AWS ECS)</li> <li> Hosted dashboards via <code>opsconsole deploy</code> </li> <li> Cost dashboard: reduce cloud spend with 1-click delete, scale down or optimize workflows</li> <li> SSO credentials support</li> <li> Additonal Providers<ul> <li> GitHub</li> <li> Google Cloud</li> <li> Cloudflare</li> <li> MongoDB</li> </ul> </li> <li> Additional Widgets<ul> <li> CI/CD </li> <li> Database Info</li> <li> CDN Info</li> <li> Edit Environment Variables</li> </ul> </li> <li> Groups support and granular permissions</li> <li> Integrations<ul> <li> Backstage </li> <li> Grafana</li> </ul> </li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"cli-reference/","title":"Usage","text":""},{"location":"cli-reference/#cli-commands","title":"CLI Commands","text":""},{"location":"cli-reference/#opsconsole","title":"opsconsole","text":"<p>Shows usage and help information</p>"},{"location":"cli-reference/#opsconsole-init","title":"opsconsole init","text":"<p>Creates a sample template file for a basic, layout only Ops Console.</p>"},{"location":"cli-reference/#opsconsole-up","title":"opsconsole up","text":"<p>Starts the ops console by pulling down the docker images for the ops api (public.ecr.aws/tinystacks/ops-api) and frontend (public.ecr.aws/tinystacks/ops-frontend) and rebuilding them using dependencies included in your yaml file. This may take several minutes depending on your system's available resources. It creates a docker networking bridge called ops-console through which the containers communicate with each other. Specify the ops console you want to use with the -c flag. </p>"},{"location":"cli-reference/#opsconsole-deploy","title":"opsconsole deploy","text":"<p>Deploys ops console on a TinyStacks hosted solution. Requires a free account and an API key. Specify the ops console you want to use with the -c flag. </p>"},{"location":"cli-reference/#opsconsole-configure","title":"opsconsole configure","text":"<p>Prompts for configuration information including an API token that will be used for deploying your console as a hosted solution. Not necessary for running locally via the \"up\" command.</p>"},{"location":"cli-reference/#opsconsole-signup","title":"opsconsole signup","text":"<p>Open signup portal to creating/managing account and API tokens. Not necessary for running locally via the \"up\" command.</p>"},{"location":"cli-reference/#opsconsole-list","title":"opsconsole list","text":"<p>List the details of your existing hosted consoles. Requires an account and an API key.</p>"},{"location":"cli-reference/#opsconsole-update","title":"opsconsole update","text":"<p>Updates the Ops Console CLI to the latest version</p>"},{"location":"cli-reference/#options","title":"Options","text":"Flag Arguments Description -a, --arch \\&lt;arch&gt; Specifies the architecture. Defaults to 'x86'. Options: 'x86', 'arm' -c, --config-file \\&lt;config-file&gt; Specifies a config file. See the <code>samples</code> folder in this repo for sample config files. Looks for config.yml in the current working directory by default. -V, --verbose Displays additional logs. -b, --backend-port \\&lt;backend-port&gt; Specifies the port to be exposed by the backend service. Defaults to port 8000. -f, --frontend-port \\&lt;frontend-port&gt; Specifies the port to be exposed by the frontend service. Defaults to port 3000. -h, --help display help for this command"},{"location":"dashboards/","title":"Dashboards","text":""},{"location":"dashboards/#concepts","title":"Concepts","text":""},{"location":"dashboards/#console","title":"Console","text":"<p>A console is a top level construct. It includes a name to identify itself, as well as dashboards, widgets, providers and dependencies. </p>"},{"location":"dashboards/#dashboard","title":"Dashboard","text":"<p>A dashboard is a page that consists of an id, a route and list of widget references. </p>"},{"location":"dashboards/#widgets","title":"Widgets","text":"<p>Widgets are components that have two functions: render and getData. getData is called in the API\u2019s server and is used to make external requests, do computations, etc. Once it is called, it sets some data on the widget itself that\u2019s passed back to the frontend, where render is called to display the widget.</p>"},{"location":"dashboards/#providers","title":"Providers","text":"<p>Providers provide data to widgets. They are backend-only code and can interact with the filesystem, keep data around, or do other more traditionally backend tasks. They can be long running and run in the background. They may be passed to widgets to provide sensitive information or long-lived information, whereas widgets are better written as quick request/response styled objects. </p>"},{"location":"dashboards/#constants","title":"Constants","text":"<p>Constants are static values that can be shared across dashboards.</p>"},{"location":"dashboards/#parameters","title":"Parameters","text":"<p>Parameters are dynamic values at the dashboard level that can be override with URL parameters.</p>"},{"location":"dashboards/#sample-dashboards","title":"Sample Dashboards","text":""},{"location":"dashboards/#basic-layout","title":"Basic Layout","text":"<p>Basic layout dashboard showcasing different widgets.</p> <pre><code>curl https://raw.githubusercontent.com/tinystacks/opsconsole/main/samples/layout-sample.yml -o ecs-dashboard-sample.yml\n\nopsconsole up -c ecs-dashboard-sample.yml\n</code></pre>"},{"location":"dashboards/#aws-dashboard","title":"AWS Dashboard","text":"<p>Basic AWS dashboard featuring metrics, logs and CLI widgets.</p> <pre><code>curl https://raw.githubusercontent.com/tinystacks/opsconsole/main/samples/aws-sample.yml -o aws-sample.yml\n\n# Modify line 6 by changing [your AWS profile] to your local AWS profile name\nopsconsole up -c aws-sample.yml\n</code></pre>"},{"location":"dashboards/#ecs-dashboard","title":"ECS Dashboard","text":"<p>Pre-built dashboard for ECS clusters featuring ECS info, tasks, metrics, logs and CLI widgets. </p> <pre><code>curl https://raw.githubusercontent.com/tinystacks/opsconsole/main/samples/ecs-dashboard-sample.yml -o ecs-dashboard-sample.yml\n\n# Modify line 6 by changing [your AWS profile] to your local AWS profile name\n# Modify lines [22-24] by changing the region, ecs clustername, and ecs service names to match resources in your account\nopsconsole up -c ecs-dashboard-sample.yml\n</code></pre>"},{"location":"dashboards/#sqs-dashboard","title":"SQS Dashboard","text":"<p>Pre-built dashboard for SQS queues featuring SQS info, metrics and CLI widgets. </p> <pre><code>curl https://raw.githubusercontent.com/tinystacks/opsconsole/main/samples/sqs-sample.yml -o sqs-sample.yml\n\n# Modify lines [6-12] by changing the region, queue names and  AWS profile to match to your account\nopsconsole up -c sqs-sample.yml\n</code></pre>"},{"location":"dashboards/#core-widgets","title":"Core widgets","text":"Name Description Panel This widget renders multiple internal widgets in a single direction, either vertical or horizontal. Tabs This widget renders multiple internal widgets in a tab view. Combine with panel or grid to make robust views. Grid This widget renders multiple internal widgets in a grid. Markdown This widget renders markdown. CLI This widget runs a bash command. The command may be multiple commands separated by ';'. You can also reference scripts that exist in the same directory as your config. (currently, only supported locally)"},{"location":"dashboards/#aws-widgets","title":"AWS widgets","text":"Name Description CloudWatch Logs Renders a widget containing logs from a CloudWatchLogs log group or log stream. CloudWatch Graph Renders a widget containing graphs populated by one or many CloudWatch metrics. ECS Info Renders a widget containing information about an ECS Service. ECS Deployments Renders a widget containing information about an ECS Service's current deployments."},{"location":"dashboards/#constants_1","title":"Constants","text":"<p>Constants are defined at the console level and can be shared across dashboards. To reference a constant, use the name of the constant prefixed with <code>$const.</code>. ex. <code>$const.const1</code>.</p> <p>Example for defining constants:</p> <pre><code>Console:\n  name: console\n  constants:\n    const1:\n      type: string\n      value: 'text'\n    const2: \n      value: true\n      type: boolean\n    const3:\n      value: 123456\n      type: number\n    const4:\n      value: '2022-04-27'\n      type: date\n</code></pre>"},{"location":"dashboards/#parameters_1","title":"Parameters","text":"<p>Parameters are dynamic values at the dashboard level that can be override with URL parameters. To reference a parameter, use the name of the parameter prefixed with <code>$param.</code> ex. <code>$param.text</code>.</p> <p>Example for defining parameters:</p> <pre><code>dashboards:\n    LayoutDashboard:\n      parameters:\n        - name: text\n          default: test 123\n        - name: num\n          type: number\n          default: 42\n        - name: bool\n          type: boolean\n        - name: date\n          type: date\n</code></pre>"},{"location":"dashboards/#providers_1","title":"Providers","text":"<p>Currently supports AWS with plans to add others! AWS provider can be configured with local profiles or Access/Secret keys.  </p>"},{"location":"dashboards/#aws","title":"AWS","text":"<pre><code>providers:\n  AwsLocalProvider:\n    id: AwsLocalProvider\n    type: AwsCredentialsProvider\n    credentials:\n      # Option A: local credentials\n      profileName: default \n      # Option B: Access/Secret keys (required when deploying with opsconsole deploy)\n      # AwsAccessKeyId:\n      # AwsSecretAccessKey: \n</code></pre>"},{"location":"dashboards/#enabling-providers-in-cli","title":"Enabling Providers in CLI","text":"<p>To enable Provider usage in the CLI widget, the Provider must implement CliEnvironmentProvider.</p>"},{"location":"dashboards/#customizing-dashboards","title":"Customizing Dashboards","text":"<p>For reference, see one of the samples in the opsconsole repository.</p>"},{"location":"dashboards/#using-widgets","title":"Using widgets","text":"<ol> <li>Define the widget in the <code>widgets</code> section of YAML</li> <li>Reference the widget in a dashboard</li> <li>Add the widget's source to the <code>dependencies</code> section of the YAML in the format <code>widget name: 'dependency package'</code></li> </ol>"},{"location":"dashboards/#using-providers","title":"Using providers","text":"<p>Providers provide data to widgets. They are backend-only code and can interact with the filesystem, keep data around, and do other more traditionally backend tasks. They are also the best way to provide credentials so that they don't leak through to the client.</p> <ol> <li>Define the provider in the <code>providers</code> section</li> <li>Reference the provider as a list item in a widget.</li> </ol> <p>See the AWS sample for reference.</p>"},{"location":"dashboards/#sharing-data-between-widgets","title":"Sharing data between widgets","text":"<p>Any property in a widget\u2019s YAML can be substituted for either the props or data of another widget. </p> Parameter Required Syntax Example Reference Yes $ref: [widget path] $ref: '#/Console/widgets/EcsInfo' Path No path: [path of data or props of the widget] path: region"},{"location":"deployment/","title":"Deployment","text":""},{"location":"deployment/#local-deployment","title":"Local Deployment","text":"<p>To run the Ops Console locally, just use the <code>opsconsole up</code> command. Its that simple!</p> <pre><code>opsconsole up -c DASHBOARD_NAME.yaml\n</code></pre>"},{"location":"deployment/#hosted-deployment","title":"Hosted Deployment","text":"<p>Deploy a hosted version of the TinyStacks Ops Console in minutes. </p> <pre><code># Routes to signup UI to obtain an auth token\nopsconsole signup; \n\nopsconsole configure\n# paste your token here\n\n# Ensure you have set an access and secret key for AWS credentials\n# deploy your Ops Console to the TinyStacks cloud!\nopsconsole deploy -c DASHBOARD-NAME.yaml\n</code></pre> <p>That's it! Deployments take a few minutes. </p> <p> When deploying a hosted version of the Ops Console, an access/secret key pair must be used. Local credentials are not saved by the Ops Console and will not work in a hosted version of Ops Console. </p>"},{"location":"get-started/","title":"Getting started","text":"<p>Follow installation instructions below to get the CLI installed.</p>"},{"location":"get-started/#installation","title":"Installation","text":"<pre><code># Install CLI\nnpm i -g @tinystacks/opsconsole;\n\n# Make sure you have Docker installed and ports 3000 and 8000 open.\n</code></pre>"},{"location":"get-started/#run-a-sample-dashboard","title":"Run a sample dashboard","text":""},{"location":"get-started/#aws","title":"AWS","text":"<p>The opsconsole repository includes multiple sample dashboards. As an example, it includes a sample dashboard that has ECS and AWS account info. To use that, follow these steps:</p> <pre><code>curl https://raw.githubusercontent.com/tinystacks/opsconsole/main/samples/ecs-dashboard-sample.yml -o ecs-dashboard-sample.yml\n\n# Modify line 6 by changing [your AWS profile] to your local AWS profile name\n# Modify lines [22-24] by changing the region, ecs clustername, and ecs service names to match resources in your account\n\nopsconsole up -c ecs-dashboard-sample.yml\n</code></pre>"},{"location":"get-started/#basic","title":"Basic","text":"<p>For a very basic dashboard that contains all the default layout elements, simply run:</p> <pre><code>opsconsole init;\nopsconsole up;\n</code></pre>"},{"location":"installation/","title":"Installation and Deploying","text":""},{"location":"installation/#pre-requisites","title":"Pre-requisites","text":"<p>To use the default installation, you need to have docker installed.</p> <p>Windows users must have Docker Desktop running.</p> <p>Also please make sure that ports 8000 and 3000 are open, as those ports are used by the API and frontend. If these ports are reserved, you can specify different ports using the <code>--backend-port</code> and <code>--frontend-port</code> flags on the <code>opsconsole up</code> command.</p>"},{"location":"installation/#install-from-the-global-npm-registry","title":"Install from the Global NPM registry","text":"<pre><code># Install from the public npm registry\nnpm i -g @tinystacks/opsconsole;\n\n# Use the CLI, refer to the usage guide below\nopsconsole -v;\n\n</code></pre>"},{"location":"installation/#local-installation","title":"Local Installation","text":"<pre><code># Clone this package\ngit clone https://github.com/tinystacks/opsconsole.git;\n\n# Install dependencies and build\nnpm i; npm run build;\n\n# Install the CLI globally\n# Using the -g option installs the ops cli to your shell scope instead of the package scope. \n#  It adds the CLI command to bin, allowing you to call opsconsole from anywhere\nnpm i -g;\n\n# Use the CLI, refer to the usage guide below\nopsconsole -v;\n</code></pre>"}]}